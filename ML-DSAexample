import numpy as np
from hashlib import sha256
import time

# Modulus and polynomial ring
q = 17
f = [1, 0, 0, 0, 1]  # Polynomial modulus x^4 + 1

# Polynomial arithmetic functions
def poly_add(p1, p2, q):
    return [(a + b) % q for a, b in zip(p1, p2)]

def poly_sub(p1, p2, q):
    return [(a - b) % q for a, b in zip(p1, p2)]

def poly_mul(p1, p2, f, q):
    deg = len(p1) + len(p2) - 1
    res = [0] * deg
    for i, a in enumerate(p1):
        for j, b in enumerate(p2):
            res[i + j] += a * b
            res[i + j] %= q
    return poly_mod(res, f, q)

def poly_mod(p, mod, q):
    while len(p) >= len(mod):
        if p[-1] == 0:
            p.pop()
            continue
        coef = p[-1]
        for i in range(1, len(mod) + 1):
            p[-i] -= coef * mod[-i]
            p[-i] %= q
        p.pop()
    return p

def poly_reduce(p, f, q):
    return poly_mod(p, f, q)

def power2round(r, d):
    r0 = [coeff % (2 ** d) for coeff in r]
    r1 = [(coeff - r0[i]) // (2 ** d) for i, coeff in enumerate(r)]
    print(f"Power2Round: r = {poly_to_str(r)}, r0 = {poly_to_str(r0)}, r1 = {poly_to_str(r1)}")
    return r1, r0

def highbits(r, gamma2):
    r1 = [(coeff // (2 * gamma2)) for coeff in r]
    print(f"HighBits: r = {poly_to_str(r)}, r1 = {poly_to_str(r1)}")
    return r1

def H(input_data, length):
    digest = sha256(input_data.encode()).hexdigest()
    bin_digest = bin(int(digest, 16))[2:].zfill(length)
    return bin_digest[:length]

def poly_to_str(p):
    terms = []
    for i, coeff in enumerate(p):
        if coeff != 0:
            if i == 0:
                terms.append(f"{coeff}")
            elif i == 1:
                terms.append(f"{coeff}x")
            else:
                terms.append(f"{coeff}x^{i}")
    return " + ".join(terms) if terms else "0"

# Polynomial representation for pretty printing
def poly_repr(poly):
    return " + ".join(f"{coef}x^{i}" if coef != 0 else "" for i, coef in enumerate(poly)).strip()

# Define input polynomials for the larger example
A = [
    [[4, 1, 2, 3], [3, 2, 4, 1]],
    [[1, 3, 1, 4], [2, 1, 3, 4]]
]

s1 = [[1, 2, -1, 1], [-1, -1, 1, -1]]
s2 = [[-2, 1, 0, 1], [0, -1, 1, 1]]

# Key Generation
def keygen():
    print("### Key Generation ###")
    
    print(f"Input Polynomials:\nA = {[[poly_to_str(poly) for poly in row] for row in A]}\ns1 = {poly_to_str(s1[0])}, {poly_to_str(s1[1])}\ns2 = {poly_to_str(s2[0])}, {poly_to_str(s2[1])}\n")
    
    t = [poly_add(poly_mul(A[0][i], s1[0], f, q), poly_add(poly_mul(A[1][i], s1[1], f, q), s2[i], q), q) for i in range(2)]
    print(f"t = A * s1 + s2 = [{poly_to_str(t[0])}, {poly_to_str(t[1])}]")

    t1, t0 = zip(*[power2round(t[i], 1) for i in range(2)])
    print(f"t0 = [{poly_to_str(t0[0])}, {poly_to_str(t0[1])}]")
    print(f"t1 = [{poly_to_str(t1[0])}, {poly_to_str(t1[1])}]")

    pk = t1
    print(f"Public Key (pk) = [{poly_to_str(pk[0])}, {poly_to_str(pk[1])}]")

    tr = H(''.join(map(str, t1)), 16)
    print(f"Hash (tr) in bits = {tr}")
    
    sk = (tr, s1, s2, t0)
    return pk, sk

# Signing
def sign(sk, message, y):
    print("\n### Signing ###")
    
    tr, s1, s2, t0 = sk
    
    mu = H(tr + message, 16)
    print(f"Message hash (mu) in bits = {mu}")
    
    print(f"Mask polynomial y = {poly_to_str(y[0])}, {poly_to_str(y[1])}")
    
    w = [poly_add(poly_mul(A[0][i], y[0], f, q), poly_add(poly_mul(A[1][i], y[1], f, q), [0]*len(f), q), q) for i in range(2)]
    print(f"w = A * y = [{poly_to_str(w[0])}, {poly_to_str(w[1])}]")

    w1 = [highbits(w[i], 1) for i in range(2)]
    print(f"w1 = [{poly_to_str(w1[0])}, {poly_to_str(w1[1])}]")

    tilde_c = int(H(mu + ''.join(map(str, w1)), 16), 2)
    print(f"Challenge (tilde_c) = {tilde_c}")
    
    c_s1 = [poly_mul([tilde_c], s1[i], f, q) for i in range(2)]
    z = [poly_add(y[i], c_s1[i], q) for i in range(2)]
    print(f"z = y + c * s1 = [{poly_to_str(z[0])}, {poly_to_str(z[1])}]")
    
    return z, tilde_c

# Verification
def verify(pk, message, sigma):
    print("\n### Verification ###")
    
    z, tilde_c = sigma

    w_prime_approx = [poly_sub(poly_mul(A[0][i], z[0], f, q), poly_mul([2 * tilde_c], pk[i], f, q), q) for i in range(2)]
    print(f"w'_Approx = [{poly_to_str(w_prime_approx[0])}, {poly_to_str(w_prime_approx[1])}]")

    w1_prime = [highbits(w_prime_approx[i], 1) for i in range(2)]
    print(f"w1_prime = [{poly_to_str(w1_prime[0])}, {poly_to_str(w1_prime[1])}]")

    pk_str = ''.join(map(poly_to_str, pk))
    w1_prime_str = ''.join(map(poly_to_str, w1_prime))

    tilde_c_prime = int(H(H(pk_str, 16) + w1_prime_str, 16), 2)
    print(f"tilde_c' = {tilde_c_prime}")

    if tilde_c == tilde_c_prime:
        print("Verification successful!")
        return True
    else:
        print("Verification failed.")
        return False

# Try different y polynomials to find one that verifies successfully
def find_correct_y(pk, sk, message, max_runtime=60):
    start_time = time.time()
    for a in range(-7, 8):  # Reduced range
        for b in range(-7, 8):
            for c in range(-7, 8):
                for d in range(-7, 8):
                    # Check if we've exceeded the maximum allowed runtime
                    if time.time() - start_time > max_runtime:
                        print("Time limit exceeded. No valid y found.")
                        return None
                    y = [[a, b, c, d], [d, c, b, a]]
                    print(f"\nTrying y = [{poly_to_str(y[0])}, {poly_to_str(y[1])}]")
                    sigma = sign(sk, message, y)
                    if verify(pk, message, sigma):
                        print(f"Correct y found: [{poly_to_str(y[0])}, {poly_to_str(y[1])}]")
                        return y
    print("No valid y found.")
    return None

# Example usage
pk, sk = keygen()
message = "11010011010101100101101101001001"
correct_y = find_correct_y(pk, sk, message, max_runtime=120)  # Set a 2-minute limit

if correct_y:
    print("\n### Printing Calculations for the Correct y ###")
    sigma = sign(sk, message, correct_y)
    verify(pk, message, sigma)
